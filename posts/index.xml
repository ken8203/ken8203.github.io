<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Hi im jaychung</title><link>https://blog.jaychung.tw/posts/</link><description>Recent content in Posts on Hi im jaychung</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 20 Aug 2022 12:01:46 +0800</lastBuildDate><atom:link href="https://blog.jaychung.tw/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>How Does Coupang Handle Massive Traffic</title><link>https://blog.jaychung.tw/posts/how-does-coupang-handle-massive-traffic/</link><pubDate>Sat, 20 Aug 2022 12:01:46 +0800</pubDate><guid>https://blog.jaychung.tw/posts/how-does-coupang-handle-massive-traffic/</guid><description>My read notes of Coupang blog series.
Coupang A South Korean e-commerce company based in Seoul, South Korea, and incorporated in Delaware, United States. Expanded to become the largest online marketplace in South Korea, and referred to as the &amp;ldquo;Amazon of South Korea&amp;rdquo;. 18M customers. Our backend strategy to handle massive traffic If all of Coupang application’s pages each directly called data from the microservices, the microservices would always have to secure high availability, and commonly used business logic code would be duplicated on the frontend without centralized management.</description></item><item><title>Golang Unit Test for Beginners</title><link>https://blog.jaychung.tw/posts/golang-unit-test-for-beginners/</link><pubDate>Fri, 03 May 2019 23:33:52 +0800</pubDate><guid>https://blog.jaychung.tw/posts/golang-unit-test-for-beginners/</guid><description>我一直覺得寫測試是程式開發中相當重要的一環，不論對自己、對他人都有相當的益處。今天來說說 golang 要怎麼寫 unit test，如果你是 golang 老手，就可以左轉了 XD
Package golang 提供一個很方便的 package - testing。但其實除了 test 以外，它還能做 benchmark，這部分有機會再寫一篇文章專門介紹。
Demo 這邊用個簡單的 sum 來 demo，此為 foo.go 檔案
package foo // Sum, to add all nums func Sum(nums ...int) int { total := 0 for _, num := range nums { total += num } return total } golang 中測試檔案會用 {file}_test.go 這種 pattern 來表示，因此這個 demo 對應的就是 foo_test.go
package foo import &amp;#34;testing&amp;#34; func TestSum(t *testing.T) { a := 1 b := 2 c := 3 expected := a + b + c actual := Sum(a, b, c) if expected !</description></item><item><title>API Rate Limiting With Redis</title><link>https://blog.jaychung.tw/posts/api-rate-limiting-with-redis/</link><pubDate>Sun, 07 Apr 2019 23:34:47 +0800</pubDate><guid>https://blog.jaychung.tw/posts/api-rate-limiting-with-redis/</guid><description>API rate limiting 在很多服務的 Open API 裡都可以看到，像是 facebook、github、twitter&amp;hellip;等等，其目的是要限制每個 consumer 的使用量，進而避免 server over loading
根據 twitter 官方的說明
Rate limiting of the standard API is primarily on a per-user basis — or more accurately described, per user access token. If a method allows for 15 requests per rate limit window, then it allows 15 requests per window per access token.
常見的 pattern 就是，每個 access token 在每段時間內有一定的使用量（usage），當該 access token 超出使用量後，發出的 request 都會得到 429 Too Many Requests 的回應</description></item><item><title>Load Complex Json Schema With Python</title><link>https://blog.jaychung.tw/posts/load-complex-json-schema-with-python/</link><pubDate>Sun, 05 Aug 2018 23:30:25 +0800</pubDate><guid>https://blog.jaychung.tw/posts/load-complex-json-schema-with-python/</guid><description>最近拿 JSON schema 來驗證自己的 API 回傳內容有沒有錯誤，在過程中遇到一點小障礙─無法讀取複雜的 JSON schema。
假設有支 API /v1/products/{product_id}，它的 schema 如下：
{ &amp;#34;$schema&amp;#34;: &amp;#34;http://json-schema.org/draft-04/schema#&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;Product resource&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;A product resource&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;, &amp;#34;additionalProperties&amp;#34;: false, &amp;#34;properties&amp;#34;: { &amp;#34;data&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;, &amp;#34;additionalProperties&amp;#34;: false, &amp;#34;properties&amp;#34;: { &amp;#34;product&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;, &amp;#34;additionalProperties&amp;#34;: false, &amp;#34;properties&amp;#34;: { &amp;#34;id&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;integer&amp;#34; }, &amp;#34;name&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34; }, &amp;#34;price&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;integer&amp;#34; }, &amp;#34;created_at&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;integer&amp;#34; }, &amp;#34;updated_at&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;integer&amp;#34; } }, &amp;#34;required&amp;#34;: [ &amp;#34;id&amp;#34;, &amp;#34;name&amp;#34;, &amp;#34;price&amp;#34;, &amp;#34;created_at&amp;#34;, &amp;#34;updated_at&amp;#34; ] } } } }, &amp;#34;required&amp;#34;: [ &amp;#34;data&amp;#34; ] } 這種簡單的 schema，直接用 json 讀取是沒問題的</description></item><item><title>Mac 下切換多版本的 PHP: php-version</title><link>https://blog.jaychung.tw/posts/mac-php-multiple-versions/</link><pubDate>Mon, 29 Jan 2018 23:27:35 +0800</pubDate><guid>https://blog.jaychung.tw/posts/mac-php-multiple-versions/</guid><description>如果你用 PHP 開發程式，一定會遇過有些 legacy 的專案需要 PHP 5.6 甚至 5.3，但新的專案卻希望走在時代的尖端，使用 PHP 7 以上的版本。這邊就來說明一下，要怎麼快速地切換 PHP 環境。
前提 你的 PHP 得是用 Homebrew 裝的，但我相信今時今日應該大家起手式都是 brew install 了吧。
裝兩個版本的 PHP 先裝 php71
$ brew install php71 $ php -v PHP 7.1.12 (cli) (built: Dec 2 2017 12:15:25) ( NTS ) Copyright (c) 1997-2017 The PHP Group Zend Engine v3.1.0, Copyright (c) 1998-2017 Zend Technologies 再來裝個 php56
$ brew install php56 . . . ==&amp;gt; Installing php56 from homebrew/php Error: Cannot install homebrew/php/php56 because conflicting formulae are installed.</description></item><item><title>PHP cURL Note</title><link>https://blog.jaychung.tw/posts/php-crul-note/</link><pubDate>Sun, 28 Jan 2018 23:20:06 +0800</pubDate><guid>https://blog.jaychung.tw/posts/php-crul-note/</guid><description>平時在做 request 都是用別人刻好的 library ，Python 用 requests，而 PHP 就用 Guzzle 之類的。但&amp;hellip;畢竟開始工作了，想說幫專案減少一點相依性，原生的功能做得到就盡量少用別人的。
結果就出事了。以後還是直接用 Guzzle 好了
所以寫篇文章來紀錄一下&amp;hellip;
一般來說，使用 cURL 會這樣子呼叫
$ch = curl_init(); curl_setopt($ch, CURLOPT_URL,&amp;#34;http://www.example.com&amp;#34;); curl_setopt($ch, CURLOPT_HEADER, false); $response = curl_exec($ch); curl_close($ch); 這樣會有一個問題，就是如果成功了，他會默默幫你輸出一個字串 ok，然後你的 API 回應就會變成
ok{ &amp;#34;data&amp;#34;: { &amp;#34;key&amp;#34;: &amp;#34;value&amp;#34; } } 這樣很尷尬，會導致 client 端 parse 錯誤，然後服務就爆了。那要如何不印出 ok 這個字樣呢？
$ch = curl_init(); curl_setopt($ch, CURLOPT_URL,&amp;#34;http://www.example.com&amp;#34;); curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $response = curl_exec($ch); curl_close($ch); 其實只需要多加一行就可以了，但這也是 cURL 的缺點，需要設定的參數太多了。不過事情就是這樣，有利有弊，端看自己如何選擇。雖然麻煩一點，但可以減少專案的相依性，感覺還是挺不錯的！
P.S. 參數太多是怎樣一個多法呢？可以參考：http://php.net/manual/en/function.curl-setopt.php</description></item><item><title>Referral and Nested Model Set</title><link>https://blog.jaychung.tw/posts/referral-and-nested-model-set/</link><pubDate>Sun, 14 Jan 2018 23:37:35 +0800</pubDate><guid>https://blog.jaychung.tw/posts/referral-and-nested-model-set/</guid><description>推薦人機制相信大家都不陌生，多多少少都有遇過，有些網站可能在註冊會員時會有一欄可以填寫推薦人，概念大致上如下：
User A 首先加入，他覺得這個服務很棒於是推薦給 User B 和 User C， User B 也感受到了服務帶給他的便利，於是推薦給 User D 和 User E，這跟老鼠會有 87% 像。
今天在吃水餃看新聞的時候，推薦人機制從我腦中呼嘯而過，就邊吃水餃邊想，如果是我，我要怎麼設計出一個有推薦人機制的會員系統？一開始想說用個 mapping table 就可以了事，但仔細一想，這樣 query 會寫不完呀！
畢竟是老鼠會推薦人機制，你會想要知道因為 User A 而進來的會員究竟有哪些人，以上面的例子來講就是
User B User C / \ User D User E 總共有四個人是因為 User A 而註冊的。
Trivial method 假設我們今天用最簡單的方法，建立一張 parent-child 的表來記錄推薦人。
create table `referral` ( `id` int(11) NOT NULL AUTO_INCREMENT, `parent` varchar(63) DEFAULT NULL, `child` varchar(63) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8; 那根據上面例子所建的表就會如下：</description></item><item><title>這陣子</title><link>https://blog.jaychung.tw/posts/after-working/</link><pubDate>Sat, 09 Dec 2017 11:43:59 +0800</pubDate><guid>https://blog.jaychung.tw/posts/after-working/</guid><description>這陣子做了幾件事：
成功嶺秋令營 開始工作 從 Pelican 搬到 Ghost 開始工作後沒多久，就想著應該要繼續寫 Blog ，最主要是能紀錄工作上碰到的問題，其次寫點東西也好。從成功嶺下來只有兩個多禮拜，卻覺得過了好久，跟以前很不一樣了呢。最顯著的差別是宵夜，上班後就幾乎沒在吃宵夜了，總想著要快點睡，不像以前十二點一到就餓慘。
至於為什麼要從 Pelican 搬到 Ghost ？倒也不是 Pelican 不好用，只是覺著要有個編輯器，打起來比較舒服。除了這點，其他的大概沒什麼變，一樣是 host 在 github page 上。
在搬家的過程遇到一點障礙，可能是 Pelican 的用戶太少了，所以沒有現成的 pelican -&amp;gt; ghost migrator，雖然舊的文章也沒幾篇，但我畢竟是個念舊的人，少歸少總得接過來，於是 Pghost 就誕生了！
接下來，希望每個禮拜都能寫一篇文章，應該還行
吧</description></item><item><title>Redux 架構下實作 Async Actions</title><link>https://blog.jaychung.tw/posts/redux-async-action/</link><pubDate>Tue, 26 Apr 2016 23:18:06 +0800</pubDate><guid>https://blog.jaychung.tw/posts/redux-async-action/</guid><description>最近專案開發上使用了 reactjs ，並採用redux架構。而依照 javascript 的特性，你沒辦法假設他會將指令執行完才繼續下一道指令，所以要怎麼做到多個 Action 異步處理呢？
舉個例子，當你 update 一份資料以後，希望他能隨後就 fetch 回來，以確保 state 裡面都是最新的資料，直觀的來寫會是這樣，但眼尖的你一定會發現不太對勁。
export const fetchData = createAction(&amp;#39;FETCH_DATA&amp;#39;, APIUtil.fetchData); export const updateData = createAction(&amp;#39;UPDATE_DATA&amp;#39;, APIUtil.updateData); this.props.updateData(data); this.props.fetchData(); // not latest result 它不會等 updateData 執行完才執行 fetchData，這樣會有順序性上的錯誤。所以我們可以在 Action 裡面動手腳，以確保fetch會在update之後。
export const fetchData = createAction(&amp;#39;FETCH_DATA&amp;#39;, APIUtil.fetchData); export function updateEventData(id, data) { return (dispatch) =&amp;gt; ( APIUtil.updateData(data) .then(() =&amp;gt; dispatch(fetchData())); ); } 不要用內建的createAction，改成自己定義 Action 就能解決這個問題囉！
Go Deeper http://redux.js.org/docs/advanced/AsyncActions.html</description></item><item><title>Procmail Pipe to Python Script</title><link>https://blog.jaychung.tw/posts/procmail-pipe-to-python-script/</link><pubDate>Tue, 29 Mar 2016 23:19:00 +0800</pubDate><guid>https://blog.jaychung.tw/posts/procmail-pipe-to-python-script/</guid><description>我們每天都在收信，那有沒有某些信件是你想挑出來，特別處理的？有的話可以使用 procmail 這個程式來幫你。
首先你家目錄下的 .forward 檔案內容必須是
&amp;#34;|/usr/local/bin/procmail&amp;#34; 確定信件會被 pipe 給 procmail 處理。
那現在重點會擺在 .procmailrc 這個檔案，這裡只會粗淺的講一下實現「用 procmail 將信件傳遞給 script 執行」。
假設我想要將從 ken8203@love.com 寄來的信傳至 mail_processing.py 做處理
:0Wc: * ^From.*ken8203@love.com | /usr/local/bin/python $HOME/mail_processing.py 如此一來就可以正確的執行了，更細節的 filter 寫法可以到網路上查查，挺多的！
OK，那 mail_processing.py 的改怎麼寫，才可以接住 pipe 過來的內容
# -*- coding: utf-8 -*- import sys import email full_msg = sys.stdin.readlines() msg = email.message_from_string(&amp;#39;&amp;#39;.join(full_msg)) with open(&amp;#39;mail.txt&amp;#39;, &amp;#39;w&amp;#39;) as fout: fout.write(msg[&amp;#39;to&amp;#39;] + &amp;#39;\n&amp;#39;) fout.write(msg[&amp;#39;from&amp;#39;] + &amp;#39;\n&amp;#39;) fout.write(&amp;#39;&amp;#39;.join(full_msg)) 就是這麼簡單！
Note 如果你的 mail.txt 遲遲不出來（有時候會 delay 一下，讓子彈飛一會兒），你可以考慮寫進 log 看看問題在哪，修改一下 .</description></item><item><title>Scikit Learn Combining Classifiers</title><link>https://blog.jaychung.tw/posts/scikit-learn-combining-classifiers/</link><pubDate>Sun, 15 Nov 2015 23:13:44 +0800</pubDate><guid>https://blog.jaychung.tw/posts/scikit-learn-combining-classifiers/</guid><description>跑 Classification 的傳統方式是決定一個 Classifier 後，透過 feature 的新增或是參數的調整，來提高準確率；而另外一個方法就是集百家之優來改善預測的結果－Essemble。
今天要介紹的是用 Voting 的方式來決定預測的結果，當然這只是 Essemble 中的其中一種，還有很多其他的方法。
Scikit-learn 的 Voting 分為 hard 與 soft。
Hard 簡單來講就是多數決，例如：
這樣預測結果就會是 class 1。
Soft 這會依照預測出來每個 class 的機率乘上你給的權重（weight）來做定奪，例如：（w1=w2=w3=1）
# of classifier class 1 class 2 class 3 class 4 1 w1 × 0.2 w1 × 0.4 w1 × 0.3 w1 × 0.1 2 w2 × 0.5 w2 × 0.2 w2 × 0.</description></item><item><title>How to use DictVectorizer (Scikit Learn)</title><link>https://blog.jaychung.tw/posts/scikit-learn-dictvectorizer/</link><pubDate>Sun, 02 Aug 2015 23:12:24 +0800</pubDate><guid>https://blog.jaychung.tw/posts/scikit-learn-dictvectorizer/</guid><description>以往使用的機器學習（Machine Learning）工具都是 LIBSVM，而這次因緣際會用了 Python 的 scikit-learn，卻不知道如何使用自己的 Feature，剛好來記錄一下。
scikit-learn 很強大的內建了幾種 Feature generator，像是 CountVectorizer、TfidfVectorizer&amp;hellip;等等。而 DictVectorizer 則可以搭配自己的 Feature ，用法如下：
from sklearn.feature_extraction import DictVectorizer vectorizer = DictVectorizer(sparse=False) features = [ {&amp;#39;feature_name_1&amp;#39;: 1, &amp;#39;feature_name_2&amp;#39;: 2}, {&amp;#39;feature_name_1&amp;#39;: 3, &amp;#39;feature_name_3&amp;#39;: 1} ] X = vectorizer.fit_transform(features) model = SomeKindofModel() clf = model.fit(X, label)</description></item><item><title>Python Chinese Processing</title><link>https://blog.jaychung.tw/posts/python-chinese-processing/</link><pubDate>Sat, 25 Jul 2015 23:10:17 +0800</pubDate><guid>https://blog.jaychung.tw/posts/python-chinese-processing/</guid><description>最近在處理大量的中文 json 檔案，一直遇到編碼上的問題，相信大家也都有遇過，
UnicodeEncodeError: 'ascii' codec can't encode characters in position 2-10: ordinal not in range(128) 也就是 ascii 無法順利編碼，最後得到了一個解決方法：調整 ensure_ascii 參數以及使用codecs。
我們用example.json當做範例：
[ { &amp;#34;category&amp;#34;: &amp;#34;數位生活&amp;#34;, &amp;#34;content&amp;#34;: &amp;#34;&amp;lt;p&amp;gt;&amp;lt;span style=\&amp;#34;font-size: 12pt;\&amp;#34;&amp;gt;&amp;lt;a href=\&amp;#34;http://mulicia.pixnet.net/album/photo/290322265\&amp;#34;&amp;gt;&amp;lt;img src=\&amp;#34;//pic.pimg.tw/mulicia/1430390908-1434509582.jpg?v=1430390937\&amp;#34; alt=\&amp;#34;\&amp;#34; /&amp;gt;&amp;lt;/a&amp;gt;&amp;amp;nbsp;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;\r\n&amp;lt;p&amp;gt;&amp;lt;span style=\&amp;#34;font-size: 12pt;\&amp;#34;&amp;gt;之前也有跟各位推薦過可以將照片上傳的空間&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;\r\n&amp;lt;p&amp;gt;&amp;lt;span style=\&amp;#34;font-size: 12pt;\&amp;#34;&amp;gt;&amp;lt;!-- more --&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;\r\n&amp;lt;p&amp;gt;&amp;lt;span style=\&amp;#34;background-color: #ffff99; font-size: 12pt;\&amp;#34;&amp;gt;&amp;lt;a style=\&amp;#34;color: #000000; text-decoration: none;\&amp;#34; href=\&amp;#34;http://mulicia.pixnet.net/blog/post/30366011\&amp;#34;&amp;gt;&amp;lt;span style=\&amp;#34;background-color: #ffff99;\&amp;#34;&amp;gt;保存相片的優質網路硬碟 Onedrive&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;\r\n&amp;lt;p&amp;gt;&amp;lt;span style=\&amp;#34;font-size: 12pt;\&amp;#34;&amp;gt;但是Onedrive改版之後竟然出現略過上傳非照片的項目，所以今天我們來使用另一款容量更大，而且不挑照片的雲端空間&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;\r\n&amp;lt;p&amp;gt;&amp;lt;span style=\&amp;#34;font-size: 12pt;\&amp;#34;&amp;gt;首先，你要先註冊mega&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;\r\n&amp;lt;p&amp;gt;&amp;lt;span style=\&amp;#34;font-size: 12pt;\&amp;#34;&amp;gt;這邊可以下載：&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;\r\n&amp;lt;p&amp;gt;&amp;lt;span style=\&amp;#34;font-size: 12pt; background-color: #ffff99;\&amp;#34;&amp;gt;&amp;lt;a href=\&amp;#34;https://itunes.apple.com/tw/app/mega/id706857885?l=zh&amp;amp;amp;mt=8\&amp;#34;&amp;gt;&amp;lt;span style=\&amp;#34;background-color: #ffff99;\&amp;#34;&amp;gt;點我&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;\r\n&amp;lt;p&amp;gt;&amp;lt;span style=\&amp;#34;font-size: 12pt; background-color: #ffff99;\&amp;#34;&amp;gt;&amp;lt;a href=\&amp;#34;https://itunes.apple.com/tw/app/mega/id706857885?l=zh&amp;amp;amp;mt=8\&amp;#34;&amp;gt;&amp;lt;span style=\&amp;#34;background-color: #ffff99;\&amp;#34;&amp;gt;https://itunes.</description></item><item><title>Mac 上安裝 OpenCV</title><link>https://blog.jaychung.tw/posts/macos-install-opencv-for-python/</link><pubDate>Mon, 18 May 2015 23:28:40 +0800</pubDate><guid>https://blog.jaychung.tw/posts/macos-install-opencv-for-python/</guid><description>OpenCV 是圖像處理裡面很猛的一個套件。之前用純 make 去安裝，每每碰壁，於是我發現 Homebrew 的美好，來記錄一下！
安裝 / Installation 在開始之前，當然要確定自己有Homebrew。
首先使用 doctor 檢查自己的 brew 有沒有問題
brew doctor 然後要轉移到 science 的倉庫裡
brew tap homebrew/science 接著就可以安裝 OpenCV 了
brew install opencv 再來換到 OpenCV 的目錄底下（要注意自己 OpenCV 的版本）
cd /usr/local/Cellar/opencv/2.4.11_1/ 好，上面是 homebrew 做的事情，應該是不會有什麼 error ，接下來才是要自己操作的部分，要先找到自己 python 的 library 路徑
echo $PYTHONPATH 像我個人是在這裡
cd /usr/local/lib/python2.7/site-packages 最後要將 OpenCV 編譯過的文件 link 到 library 下
ln -s /usr/local/Cellar/opencv/2.4.11_1/lib/python2.7/site-packages/cv.py cv.py ln -s /usr/local/Cellar/opencv/2.4.11_1/lib/python2.7/site-packages/cv2.so cv2.so 這樣大致上就完成啦！
import cv2</description></item><item><title>THE FUTURE IS NOW</title><link>https://blog.jaychung.tw/posts/the-future-is-now/</link><pubDate>Fri, 03 Apr 2015 23:02:15 +0800</pubDate><guid>https://blog.jaychung.tw/posts/the-future-is-now/</guid><description>從以往的經驗來看，未來大致上長這樣，不那麼清楚，也肯定艱難。
抓緊機會，努力不讓自己怠慢。如果女人最大的敵人是地心引力，那我大概就是惰性 LOL</description></item><item><title>Apply Tipue search on Pelican</title><link>https://blog.jaychung.tw/posts/apply-tipuesearch-on-pelican/</link><pubDate>Sat, 14 Mar 2015 23:04:30 +0800</pubDate><guid>https://blog.jaychung.tw/posts/apply-tipuesearch-on-pelican/</guid><description>每個部落格都需要「搜尋」這個功能，文章少時還好，多了以後想找就不方便。Pelican 並沒有內建文章搜尋的功能，但倒是有個滿酷的套件， Tipue Search 。
Tipue Search Serializes generated HTML to JSON that can be used by jQuery plugin.
簡潔有力的說明，就是將文章轉換成 JSON 檔案，搭配上 jQuery 進行文章搜尋。
設定 / Configuration Tipue Search 在 python 的部分是仰賴 BeautifulSoup 這個套件，所以在使用前得先確定自己有沒有安裝。
pip install beautifulsoup4 下載 Tipue Search，然後將裡面的 static 檔案放置到自己主題的目錄下。（themes/&amp;lt;your_theme&amp;gt;/static/tipuesearch/）
下載 Tipue Search Plugin，放到 plugin 資料夾底下，如果還沒有 plugin 這個資料夾可以自己創一個。
編輯 pelicanconf.py 然後要編輯自己的 pelicanconf.py，像我的資料夾名稱是 pelican-plugins，並且要加上 DIRECT_TEMPLATES ，確認要 parse 成 JSON 的頁面有哪些。
PLUGIN_PATH = &amp;#39;pelican-plugins&amp;#39; PLUGINS = [&amp;#39;tipue_search&amp;#39;] DIRECT_TEMPLATES = ((&amp;#39;index&amp;#39;, &amp;#39;tags&amp;#39;, &amp;#39;categories&amp;#39;, &amp;#39;authors&amp;#39;, &amp;#39;archives&amp;#39;, &amp;#39;search&amp;#39;)) 編輯 templates 第一個部分就是先加上 css ：</description></item><item><title>How to Use Flask Login</title><link>https://blog.jaychung.tw/posts/how-to-use-flask-login/</link><pubDate>Mon, 23 Feb 2015 23:07:15 +0800</pubDate><guid>https://blog.jaychung.tw/posts/how-to-use-flask-login/</guid><description>&lt;h2 id="flask-login-可以做什麼">Flask-Login 可以做什麼？&lt;/h2>
&lt;blockquote>
&lt;p>Flask-Login provides user session management for Flask. It handles the common tasks of logging in, logging out, and remembering your users’ sessions over extended periods of time.&lt;/p>
&lt;/blockquote>
&lt;p>簡而言之就是替網站管理 session，這裡只說明最一般的用法，其功能當然不僅於此，如有需要可以參考 &lt;a href="https://flask-login.readthedocs.org/en/latest/">官方的說明文件&lt;/a>。&lt;/p></description></item><item><title>Apply Fancybox on Pelican</title><link>https://blog.jaychung.tw/posts/apply-fancybox-on-pelican/</link><pubDate>Sun, 15 Feb 2015 23:21:27 +0800</pubDate><guid>https://blog.jaychung.tw/posts/apply-fancybox-on-pelican/</guid><description>&lt;h2 id="fancybox-是什麼">Fancybox 是什麼？&lt;/h2>
&lt;p>我們先看看官方說明&lt;/p>
&lt;blockquote>
&lt;p>fancyBox is a tool that offers a nice and elegant way to add zooming functionality for images, html content and multi-media on your webpages. It is built on the top of the popular JavaScript framework jQuery and is both easy to implement and a snap to customize.&lt;/p>
&lt;/blockquote>
&lt;p>重點就是達到 &lt;strong>zooming&lt;/strong> 的感覺。&lt;/p></description></item><item><title>Moving to Pelican</title><link>https://blog.jaychung.tw/posts/moving-to-pelican/</link><pubDate>Fri, 13 Feb 2015 23:26:59 +0800</pubDate><guid>https://blog.jaychung.tw/posts/moving-to-pelican/</guid><description>while True: self.update(life) 尋尋覓覓，換了好幾種 Blog ，但都不是很喜歡，就覺得跟語言有關係 lol ，於是找到這個 pelican ，看起來親切多了！
Keep going.</description></item></channel></rss>