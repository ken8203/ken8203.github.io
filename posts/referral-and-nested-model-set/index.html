<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Referral and Nested Model Set &#183; Hi im jaychung</title><link rel=stylesheet href=https://blog.jaychung.tw/css/slim.css><link rel=stylesheet href=https://blog.jaychung.tw/css/highlight.min.css><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro" rel=stylesheet type=text/css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico></head><body><div class=container><div class=header><h1 class=site-title><a href=https://blog.jaychung.tw/>Hi im jaychung</a></h1><p class=site-tagline></p><div class=nav><a class=nav-btn href=#><span class="ci ci-burger"></span></a><ul class=nav-list><li class=spacer>&ac;</li><li><a href=https://github.com/ken8203>Github</a></li><li><a href=https://twitter.com/jaychungtw>Twitter</a></li></ul></div></div><div class=content><div class=post><h2 class=post-title><a href=https://blog.jaychung.tw/posts/referral-and-nested-model-set/>Referral and Nested Model Set</a></h2><div class=post-content><p><strong>推薦人機制</strong>相信大家都不陌生，多多少少都有遇過，有些網站可能在註冊會員時會有一欄可以填寫推薦人，概念大致上如下：</p><p><img src=/content/images/2018/01/Untitled-Diagram-1.png alt="Figure 1. 推薦人示意圖"></p><p><code>User A</code> 首先加入，他覺得這個服務很棒於是推薦給 <code>User B</code> 和 <code>User C</code>， <code>User B</code> 也感受到了服務帶給他的便利，於是推薦給 <code>User D</code> 和 <code>User E</code>，<del>這跟老鼠會有 87% 像</del>。</p><p>今天在吃水餃看新聞的時候，推薦人機制從我腦中呼嘯而過，就邊吃水餃邊想，如果是我，我要怎麼設計出一個有推薦人機制的會員系統？一開始想說用個 mapping table 就可以了事，但仔細一想，這樣 query 會寫不完呀！</p><p>畢竟是<del>老鼠會</del>推薦人機制，你會想要知道因為 <code>User A</code> 而進來的會員究竟有哪些人，以上面的例子來講就是</p><pre><code>   User B             User C
   /    \
User D   User E
</code></pre><p>總共有四個人是因為 <code>User A</code> 而註冊的。</p><h1 id=trivial-method>Trivial method</h1><p>假設我們今天用最簡單的方法，建立一張 parent-child 的表來記錄推薦人。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>create</span> <span style=color:#66d9ef>table</span> <span style=color:#f92672>`</span>referral<span style=color:#f92672>`</span> (
    <span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> AUTO_INCREMENT,
    <span style=color:#f92672>`</span>parent<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>63</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
    <span style=color:#f92672>`</span>child<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>63</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
    <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>)
) ENGINE<span style=color:#f92672>=</span>InnoDB AUTO_INCREMENT<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span> <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8;
</code></pre></div><p>那根據上面例子所建的表就會如下：</p><table><thead><tr><th>id</th><th>parent</th><th>child</th></tr></thead><tbody><tr><td>1</td><td>userA</td><td>userB</td></tr><tr><td>2</td><td>userA</td><td>userC</td></tr><tr><td>3</td><td>userB</td><td>userD</td></tr><tr><td>4</td><td>userB</td><td>userE</td></tr></tbody></table><p><strong>問題來了</strong>：想要知道因為 <code>User A</code> 而進來的會員究竟有哪些人？</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>SELECT</span> child <span style=color:#66d9ef>FROM</span> <span style=color:#f92672>`</span>referral<span style=color:#f92672>`</span> <span style=color:#66d9ef>WHERE</span> parent<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;userA&#39;</span>; <span style=color:#75715e>-- root
</span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> child <span style=color:#66d9ef>FROM</span> <span style=color:#f92672>`</span>referral<span style=color:#f92672>`</span> <span style=color:#66d9ef>WHERE</span> parent<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;userB&#39;</span>; <span style=color:#75715e>-- level 1
</span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> child <span style=color:#66d9ef>FROM</span> <span style=color:#f92672>`</span>referral<span style=color:#f92672>`</span> <span style=color:#66d9ef>WHERE</span> parent<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;userC&#39;</span>; <span style=color:#75715e>-- level 2
</span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> child <span style=color:#66d9ef>FROM</span> <span style=color:#f92672>`</span>referral<span style=color:#f92672>`</span> <span style=color:#66d9ef>WHERE</span> parent<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;userD&#39;</span>; <span style=color:#75715e>-- level 2
</span></code></pre></div><p>你能想像當你系統的推薦人層數成長後，query 的複雜度也會隨之提高，必然得用遞迴的方式下去查詢，如此一來對於 DB 的負擔也就加重了。</p><p>但其實觀察一下 Figure 1，可以發現推薦人機制本身就是樹狀結構的東西，所以如果使用一個本性相符的方法，可能會比較適合一點。</p><h1 id=nested-set-model>Nested set model</h1><p><img src=/content/images/2018/01/nested-set-model.png alt="Figure 2. Nested set model"></p><p>Nested set model 就是一個適合處理樹狀結構資料的資料模型，它的特性剛好都是推薦人機制需要的東西：</p><ul><li>不需要遍歷整顆樹</li><li>有效率的獲取節點</li><li>有效率的計算節點數量</li></ul><p>由 Figure 2 可以發現，每個 User 旁邊都多了兩個數字，分別是 <code>left</code> 和 <code>right</code>，這是 Nested set model 的特別之處。假設一開始只有 <code>UserA</code></p><p><img src=/content/images/2018/01/1.png alt></p><p>再來加入 <code>UserB</code> 時會變成</p><p><img src=/content/images/2018/01/2.png alt></p><p>接著加入 <code>UserC</code></p><p><img src=/content/images/2018/01/3.png alt></p><p>最後再加一層，加入 <code>UserD</code></p><p><img src=/content/images/2018/01/4.png alt></p><p>再回到 <strong>「因為 <code>User A</code> 而進來的會員究竟有哪些人？」</strong> 這個問題，你會發現我們只需要</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> <span style=color:#f92672>`</span>referral<span style=color:#f92672>`</span> <span style=color:#66d9ef>WHERE</span> <span style=color:#f92672>`</span>username<span style=color:#f92672>`=</span><span style=color:#e6db74>&#39;userA&#39;</span>;
<span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> <span style=color:#f92672>`</span>referral<span style=color:#f92672>`</span> <span style=color:#66d9ef>WHERE</span> <span style=color:#f92672>`</span>lft<span style=color:#f92672>`</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>and</span> <span style=color:#f92672>`</span>rgt<span style=color:#f92672>`</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>8</span>;
</code></pre></div><p>使用 Nested set model 後我們只需要做一次查詢，不管推薦人的層數有幾層，但如果是 Trivial method ，有幾層就要 query 幾次，這個感受度一下就有了。</p><h3 id=如何建構一顆樹>如何建構一顆樹</h3><p>Nested set model 有幾個重要的欄位，分別是 <code>lft</code>、<code>rgt</code>、<code>level</code>
、<code>parent_id</code> 和 <code>tree_id</code>，至於其他的欄位就因應用而異了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#f92672>`</span>referral<span style=color:#f92672>`</span> (
  <span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> AUTO_INCREMENT,
  <span style=color:#f92672>`</span>username<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>20</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
  <span style=color:#f92672>`</span>lft<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
  <span style=color:#f92672>`</span>rgt<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
  <span style=color:#f92672>`</span><span style=color:#66d9ef>level</span><span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
  <span style=color:#f92672>`</span>tree_id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
  <span style=color:#f92672>`</span>parent_id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
  <span style=color:#f92672>`</span>user_id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
  <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>),
  <span style=color:#66d9ef>UNIQUE</span> <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>username<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>username<span style=color:#f92672>`</span>),
  <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>parent_id<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>parent_id<span style=color:#f92672>`</span>),
  <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>referral_level_idx<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span><span style=color:#66d9ef>level</span><span style=color:#f92672>`</span>),
  <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>referral_lft_idx<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>lft<span style=color:#f92672>`</span>),
  <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>referral_rgt_idx<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>rgt<span style=color:#f92672>`</span>),
  <span style=color:#66d9ef>CONSTRAINT</span> <span style=color:#f92672>`</span>referral_ibfk_1<span style=color:#f92672>`</span> <span style=color:#66d9ef>FOREIGN</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>parent_id<span style=color:#f92672>`</span>) <span style=color:#66d9ef>REFERENCES</span> <span style=color:#f92672>`</span>referral<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>) <span style=color:#66d9ef>ON</span> <span style=color:#66d9ef>DELETE</span> <span style=color:#66d9ef>CASCADE</span>
) ENGINE<span style=color:#f92672>=</span>InnoDB AUTO_INCREMENT<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span> <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8;
</code></pre></div><p>或許有人會疑惑 <code>tree_id</code> 的用途，這是用來支援 Multi-tree 時使用的，試想有些人一開始註冊時可能沒有推薦人，但之後卻將服務推薦給別人，這時候他就會自成一顆樹。</p><p>當然 Nested set model 不只可以用在推薦人機制上，只要是任何長得像樹的東西，都可以試試看。</p></div></div></div><div class=footer><p>Copyright © 2020. Powered by Hugo.</p></div></div><script src=https://blog.jaychung.tw/js/slim.js></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-56558534-1','auto');ga('send','pageview');</script></body></html>