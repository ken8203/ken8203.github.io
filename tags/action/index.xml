<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>action on Hi im jaychung</title><link>https://blog.jaychung.tw/tags/action/</link><description>Recent content in action on Hi im jaychung</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 26 Apr 2016 23:18:06 +0800</lastBuildDate><atom:link href="https://blog.jaychung.tw/tags/action/index.xml" rel="self" type="application/rss+xml"/><item><title>Redux 架構下實作 Async Actions</title><link>https://blog.jaychung.tw/posts/redux-async-action/</link><pubDate>Tue, 26 Apr 2016 23:18:06 +0800</pubDate><guid>https://blog.jaychung.tw/posts/redux-async-action/</guid><description>最近專案開發上使用了 reactjs ，並採用redux架構。而依照 javascript 的特性，你沒辦法假設他會將指令執行完才繼續下一道指令，所以要怎麼做到多個 Action 異步處理呢？
舉個例子，當你 update 一份資料以後，希望他能隨後就 fetch 回來，以確保 state 裡面都是最新的資料，直觀的來寫會是這樣，但眼尖的你一定會發現不太對勁。
export const fetchData = createAction(&amp;#39;FETCH_DATA&amp;#39;, APIUtil.fetchData); export const updateData = createAction(&amp;#39;UPDATE_DATA&amp;#39;, APIUtil.updateData); this.props.updateData(data); this.props.fetchData(); // not latest result 它不會等 updateData 執行完才執行 fetchData，這樣會有順序性上的錯誤。所以我們可以在 Action 裡面動手腳，以確保fetch會在update之後。
export const fetchData = createAction(&amp;#39;FETCH_DATA&amp;#39;, APIUtil.fetchData); export function updateEventData(id, data) { return (dispatch) =&amp;gt; ( APIUtil.updateData(data) .then(() =&amp;gt; dispatch(fetchData())); ); } 不要用內建的createAction，改成自己定義 Action 就能解決這個問題囉！
Go Deeper http://redux.js.org/docs/advanced/AsyncActions.html</description></item></channel></rss>